テーブル設計手順

# はじめに
- 作りたいシステムの概要をもとに要件を定義し、要件を満たすようなRDBを設計する
- アンチパターンなども説明する

# 設計の概要
## 設計の流れ
- 概念スキーマ（論理設計) → 内部スキーマ（物理設計）の順で設計が進む
- さらに論理設計は以下のような手順で設計を行う
  1. エンティティの抽出
  1. エンティティの定義(=テーブルの定義)
  1. 正規化
  1. ER図の作成
- エンティティ、リレーション(テーブル同士に線を結ぶ)、属性（エンティティになにがあるか）、関連の多重度の流れ（1:多など）

# エンティティの抽出
- エンティティとは、ある共通項を持ったデータのこと。物理的実体がともわなくても良い
- 物理的実体を含んでいなくてもいい
## 例
## ポイント
- まずは、設計したいシステムの要件に基づき、エンティティを取り出す。
- 正規化などの過程で新たに見えてくるものがあるので、エンティティの抽出は可能な限りでよい。
# エンティティの定義(=テーブルの定義)
キーはなににするか、どういった属性が含まれているかなどを定義すること。テーブルという単位でエンティティを表現する。テーブルとは共通点を持ったレコード。
## 例
- 下線は主キーを表す p75
- キーと呼ぶ
- 主キーと呼ぶ
- 外部キーと呼ぶ
- 外部キーとは親子関係のようなもの。hogeが親でhugaが子。(hogeがhugaに対して1対多の関係)
## テーブルのポイント
- テーブル名は英語ならば複数形/複数名詞で書ける。そうでなければそのテーブルのどこかに間違いがある。
- 名前は重複しない（ただし、同じ範囲のドメイン（スキーマ）内という前提）
## 列のポイント
- テーブルの列の制約。ハイフンではなくアンダーバーを利用する。最初はアルファベット。p80
- 全てのテーブルにid列を用いる安易な考えはしてはいけない p42
- NOT NULL 制約はなるべくつける
- ダブルミーニングだめ p196
- 単一参照テーブルダメ p199
## キーのポイント
- 名前をキーに使う、可変長文字列(VARCHAR)を使うのはアンチパターン p214
- 値の変わる列を主キーや外部キーにするとよくない
- キーとなる列にはコードやIDなど表記体系の定まった固定長文字列を利用する p78
- 固定長文字列のコード列がキーには向いている
### 主キーのポイント
- 主キーはNULLを含んではいけない
- 主キーはidという名前を避ける（アンチパターン)
### 外部キーのポイント
- 子から削除をする。親(1)、子(多。子テーブルにFKが存在する。親に存在しない値は子のテーブルで作成できない。＝参照整合性制約) p77。
- 子に対して複数の親がいるときは設計が間違っている可能性あり(ポリモーフィック)
  - 共通テーブル or 交差テーブルを利用する。
- 参照整合性制約をつけているか。
  - 制約をつけることで、親に存在しない値は子のテーブルで作成できなくなるので、間違ったデータを入れることを防ぐことができる。
  - 別にレスポンス遅くならない(TODO: なんで参照整合性制約嫌うんだっけ?たしか柔軟に削除できない（絶対子から削除する）とか、アップデートが基本できないからだった気がする。)
  - もし外部キー制約をつけないと列を削除するときに子テーブルも正しく更新できるかなど考える必要がある。 p44
# 正規化
テーブルは第3正規形までするのが基本。正規化とはテーブルの分解。分解の粒度によって正規形の名前がある。
従属という言葉がキーワードになる。AによってBが一意に決まる時の記号は{A} -> {B}となる。具体例は以下で説明する。
## 第1正規形
ひとつのセルに1つの値であること。
### 例
- 列持ち(マルチカラムアトリビュート)と呼ぶ。これは要素を追加したいときにカラムを増やさないといけないのでダメな設計
- この場合 {hoge}->{huge}とかける。
### ダメな例
- カラムに複数データが入ると一意にデータを識別できない。
### ポイント
- ひとつのセルに1つだけか
- 列持ちになってるか？なっていたら分解が足りていないので、さらに分解することを検討
- カンマ区切りのフォーマットで格納していないか？（一つのカラムに要素を詰め込んでしまうケース）。さらに分解することを検討する
## 第2正規形
### 例
### ダメな例
### ポイント
## 第3正規形
- 一つのカラムに一つの要素を入れるのが第一正規形だけど、カンマ区切りのフォーマットで格納するのはアンチパターン（一つのカラムに要素を詰め込んでしまうケース）
- 部分関数従属になるキーと従属列を独立のテーブルにすると第二正 規形 p93
- 主キーによって一意にレコードが定まるか確認。
- 複合キーの場合、主キーの一部で一意に定まってしまわないか確認。つまり複合キーでようやく一意に定まることを確認。
- 関数従属をチェックするのが正規化を進めるポイント
### 例
### ダメな例
### ポイント

# ER図の作成
## 例
## ダメな例
### 多:多
### 1:1
### 主キーがない
- 主キーが決まらなければ代理キーで。代理キーはDB側で用意されているオートナンバリングで実装するのがいい。
### 子に対して親が複数
- ポリモーフィック関連（複数のテーブルを参照する）
- 親が二つあって、子のテーブルにある外部キーがどちらかの親に属しているというようなパターン。参照制約つかえなくなるし、JOINすると片方の親はNULLになる。
  - 本来の関連が逆になっている可能性があるので参照を逆にする
  - 共通テーブルを作成する。
  - 交差テーブルを作成する。

## ポイント
- あるテーブルの主キーが他のテーブルに列として含まれるか着目 p126
- 1:1というテーブルはできないので、そのようなものがある場合正規化が間違ってる
- 多：多になっていないか？
  - あるなら中間テーブルを作成する。



＝＝＝＝＝
## メモ
複合キーでいいの？どっかで単一キーのほうが主キーには向いてるって聞いた気がする。
